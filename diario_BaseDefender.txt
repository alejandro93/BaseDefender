
- Descarga de Unity 5.
- Aprendizaje de uso de Unity.
- Tutoriales de internet sobre Unity.
- Descarga de sprites de internet.
- Descarga de las sdk de Android Studio para la exportación del proyecto a Android.
- Configuración del proyecto.
- Pruebas de exportación en C# y JavaScript para Android.
- Creación de escena principal vacía.
- Creación de objeto Jinete de tipo GameObject.
- Asignado sprite a Jinete.
- Creación y asignación de script de movimiento lateral JineteMov.cs para Jinete. Para ello se inicializan variables de tipo float que definirán la velocidad de movimiento del objeto.
//Los objetos de tipo GameObject tienen definidas las variables X e Y que recogen el valor en el eje de las X y de las Y de la pantalla en el lugar en el que se encuentran.
- Creada escena para probar animaciones y terreno.
- Uso de un sprite y un fondo prefabricado de Unity para hacer de fondo del nivel. (Sujeto a cambios)
- Creación de objetos GameObject de torres aliadas y enemigas con un sprite para cada una.
- Asignada propiedad Box Collider 2D para los objetos tipo torre. No asignada la propiedad RigidBody 2D (explicada más adelante).
- Prueba de colisión.
// Las animaciones son clips (.anim)
- Creado modelo animado de Jinete usando la herramienta de animación para sprites de Unity.
- Creación automática de controlador de sprites asignados a cada animación.
- Creada animación para correr y para atacar de Jinete.
- Creado nuevo objeto Jinete y asignada la animación por defecto.
- Creada animación para muerte de las unidades.
- Creada carpeta Prefab en la que se guardan los objetos del juego.
- Guardado Jinete en Prefab.
- Recargado Jinete.
- Asignado cuerpo rígido con propiedades de Unity, RigidBody 2D. 
// Esto controla en el eje de las X y el eje de las Y dónde se encuentra el objeto de tipo GameObject en cada ciclo de juego, además permite activar o desactivar la gravedad, una fuerza de aceleración que ya viene definida en las librerías que importa Unity. Rigidbody 2D es la clase que usa Unity como motor de físicas.
// El Collider establece que el objeto es "sólido" y por tanto el motor de físicas debe detener el GameObject que se encuentre en contacto con este objeto, es decir, cuando su valor X y su valor Y sean el mismo.
// Esto evita que los objetos se atraviesen ya que no pueden ocupar el mismo espacio.
- Añadido Collider a Jinete desde la interfaz de Unity.
- Añadida variable booleana al script de JineteMov.cs para saber si está chocando con algo.
/* En fase de prueba
- Creado nuevo script Movement que será el controlador de cada objeto, en lugar de que cada objeto tenga su propio script de movimiento. 
*/
- Creamos un vector que ponemos a 0 en cada ciclo del juego.
- Creado método colisionEvent, al que le pasamos por parámetro un objeto de tipo Collision2D (en las librerías de Unity viene definido este objeto cuyos valores son los valores de X e Y que ocupa el objeto al que pertenece).
/* En fase de prueba
- Iniciamos una variable de tipo Movement dentro de JineteMov, con la cual controlaremos si debemos mover al Jinete o no.
- Dentro de void Start() (el cual se ejecuta una vez inicializado el objeto) recogemos el valor de la variable de tipo Movement.
*/
- Asignado tag "Enemy" a Jinete.
//Los Colliders tienen definida una variable tag de tipo String por defecto vacía. Puedes escribir desde la interfaz la cadena de caracteres que quieras y mediante una llamada al Collider en otra clase puedes obtener el tag del collider de modo que puedas identificar con qué objeto está entrando en contacto.
- Creado método colision en JineteMov
//Este método busca el nombre del tag del objeto y si coincide ejecuta una accion u otra.
- Creado objeto con animacion Leon, obtenidos sprites de internet.
- Creada animacion de correr para Leon.
- Creada animacion de atacar para Leon.
- Asignada animaciones de leon y animacion de muerte al objeto Leon.
- Asignado tag "Ally" a Leon.
- Modificado script de movimiento de Jinete para reconocer tag de "Ally"
- Asignados los scripts a ambos objetos.
- Ambos objetos se desvían al chocar en lugar de pararse. 
- Establecidas transiciones entre animaciones.
- Creada variable de tipo Animator en el script de movimiento para controlar el estado de la transición de las animaciones según la acción del objeto.
- Establecido ángulo para los objetos mediante la interfaz de Unity, de modo que no roten los objetos al chocar con otros. Mediante esto solucionamos el desvío de los objetos al chocarse.
- Establecido método OnTriggerEnter como sustituto de colision.
- Asignado mediante la interfaz de Unity la variable animator a Jinete.
- Asignado isTrigger mediante la interfaz gráfica de Unity a Jinete y Leon. 
// isTrigger devuelve OnTriggerEnter, OnTriggerExit, OnTriggerStay...
- Sobreescrito método OnTriggerEnter y OnTriggerExit para Jinete.
- Añadido estados para cambiar animacion de Leon
- Pasados componentes "Animator" en forma de variables privadas que son recogidas por getComponent <Animator>
- Añadida funcion de movimiento a Leon y metodos OnTriggerEnter2D y OnTriggerExit2D
- Añadido variables de daño y ataque a Leon y Jinete
- Recogemos el objeto JineteMov desde Leon con GetComponent<JineteMov>
- Obtenemos el daño de la unidad en cuestión.
// En C# importas namespaces, no como en Java que importas types directamente.
-  Cambiado métodos, eliminado GetComponent por problemas técnicos, asignado un switch en el que buscamos el tag y según su resultado modificamos la variable daño, aplicamos un estado de animacion y avanzamos a detenemos el objeto.
- Creados metodos detenerVelocidad() que establece this.X a 0 y resetVelocidad para devolver this.X a su valor original.
- Asignados los tag de forma manual mediante gameObject.tag
- En el Update restamos a vida el valor de daño.
- Fallo en el bucle, se ha de controlar el tiempo de la aplicación para disminuir la vida de forma no instantánea o infinita.
- Añadida variable recibeDanyo de tipo bool
- Añadida condicion a bucle Update, si recibeDanyo es true, le restamos a vida danyo
- Añadido if a bucle Update, si vida <= 0, pasamos AnimState a 2 para activar la animacion de muerte
- Creado método destruirObjeto, dentro usamos Destroy (this.gameObject)
- Creado variable choque y tiempo que guardan el tiempo (Time.time) en el que se encuentra la aplicación. 
- Inicializado choque en OnTriggerEnter2D, de modo que es el tiempo en el que chocan los objetos.
- La variable tiempo la guardamos en el Update, de modo que está continuamente guardando el tiempo en el que se encuentra la aplicación desde que se inició.
- Mediante un if comparamos si la diferencia entre tiempo y choque es de 1 segundo, si es el caso, esto restará danyo a la vida del objeto.
- Renombrado choque a golpe.
- Redefinido golpe por cada vez que disminuimos la vida, lo igualamos a tiempo, de modo que tenga que volver a haber una diferencia de un segundo para disminuir vida.
- Añadida condición del mismo modo que antes, que la resta de tiempo-golpe sea >= 1, esta vez en el if en el que entra cuando vida llega a 0, para dar un segundo a la animación de muerte antes de destruir el objeto.
- Añadido a la condicion que recibeDanyo sea false, lo cual ocurrirá cuando vida llegue a 0 o menos. Esto es porque de lo contrario, seguimos entrando en el bucle que modifica golpe a tiempo y nunca entramos en la condicion que destruye el objeto. De esta forma dejamos de actualizar golpe a tiempo y cuando tiempo-golpe >= 1, el objeto se destruirá mediante el método destruirObjeto() creado anteriormente.
- Añadido recibeDanyo = false a OnTriggerExit2D
- Creado objeto Soldado, animado con animaciones de movimiento, ataque y muerte usando el animador de Unity
- Creado el script SoldadoMov.cs
- Añadido transform.localScale para Soldado porque el sprite miraba en la otra dirección.
- Añadido tag "SoldadoAlly"
- Quitada gravedad y fijado el ángulo mediante la interfaz de Unity.
- Creado SoldadoEnemy, animaciones de correr atacar y morir
- Creado script SoldadoEnemyMov.cs para SoldadoEnemy
- Añadido componentes RigidBody 2D, Box Collider 2D para los nuevos soldados
- Hechos IsTrigger, angulo fijado y gravedad 0 mediante la interfaz.
- Eliminado el script Movement.
- Descubierto errata, cuando objetos aliados chocan, no se superponen si no que se bloquean entre ellos.
- Eliminado componente RigidBody 2D de los objetos.
- Cambiado OnTriggerEnter2D (Collider2D target) y demás eventos por OnCollisionEnter2D (Collision2D target)
- Añadido OnCollisionStay2D para el comportamiento mientras permanecen chocando.
- Guardados todos los gameObject en la carpeta Prefabs
- Iniciada escena Menu
- Importados sprites de edificios, terreno y skybox
- Leer y aprender cómo usar el Canvas de Unity
- Cambiado fondo del Menu
- Cambiado nombre de la escena del juego a Juego
- Creado Canvas tanto en Menu como en Juego, ocupa el mismo espacio que la cámara (seleccionado mediante la interfaz de Unity)
- Creados botones Nuevo juego, Record y Instrucciones en el Menu
- Cambiado su color y su texto
- Creado script CargarEscena
- Creado método cargarEscena para abrir una escena nueva
- Asignado a un objeto vacío en el juego
- Asignado objeto al OnClick() de los botones
- Elegido método a ejecutar del script en el OnClick del botón mediante la interfaz de Unity
- Añadidos botones de Regresar en todas las pantallas
- Asignado script cargarEscena a cada uno de los botones Regresar
- El botón Regresar de la pantalla Juego tiene como texto "Abandonar", pendiente de añadir método que guarde record de partidas.
- Añadido botón Salir en el menu
- Añadido método salir al script CargarEscena, ejecuta Application.Quit();
- Asignado salir a boton Salir
- Devueltos todos los métodos OnCollisionEnter a OnTriggerEnter, y mediante la interfaz, los objetos devueltos a IsTrigger. Esto es porque a pesar de colisionar, no mandaban ningún evento, al parecer es necesario activar un Trigger para que envíen dicho evento además de estar colisionando. 
- Eliminados del "default" de los switches sus acciones.
- Eliminado modificacion de danyo en OnTriggerStay2D
- Aplicado los mismos cambios al resto de scripts de los objetos.
- Creado script ClonarObjeto con los metodos clonarLeon y clonarSoldado
- Cada uno de esos métodos ejecuta un método Instantiate con el nombre del prefab, su posicion y su rotacion
- Asignado el script a los botones Infanteria y Caballeria
- Establecida posicion x e y de origen para que se generen los objetos.
- Creado script GenerarEnemigos.
- Añadido Instantiate al bucle start() para generar el primer enemigo
- Añadida variable de tipo int enemyCount que llevará la cuenta de los enemigos instanciados (++ cada vez que hagamos Instantiate)
- Añadidas variables de tipo float tiempo y tiempoDesdeGenerado
// Estas serán las variables que usemos para identificar el momento en el que estamos de la partida y el momento en el que se generó la última unidad enemiga, de modo que saquemos la siguiente
- Igualado tiempoDesdeGenerado a tiempo tras cada Instantiate.
// Cuantas más unidades hayamos generado, más Instantiate haremos, para aumentar la dificultad de la oleada.
- Detectada errata, al destruirse el objeto, se destruye el script asociado a él, por lo que cuando realizamos Instantiate del objeto, se crea con los parámetros de su último clon.
- Creado panel en Instrucciones.
- Creado ScrollRect (renombrado a ScrollView), un Text y un Scrollbar
- Asignado el Scrollbar al ScrollRect mediante interfaz de Unity
- El Text es el Content del ScrollRect
- Utilizado componente Mask para tapar el contenido sobrante de Text del Panel, que se desliza con el Scrollbar que hemos asignado.
- Introducido texto a modo de instrucciones en el Text
- Añadida variable muerte de tipo bool que se pone a true cuando vida baje de 0.
- Modificado bucle de juego.
- Añadido condicion if (muerto == false) para el OnTriggerStay2D
- Comentados los SetActive y los Destroy de las unidades
- Creados script TorreAlly y TorreEnemy
- Inicializada variable vida en scripts de las torres
- Creados métodos OnTriggerEnter2D, OnTriggerStay2D y OnTriggerExit2D
- Creadas variables de danyo, golpe, tiempo y recibeDanyo.
- Introducido switch en los OnTrigger siguiendo los casos de las unidades para modificar los valores de danyo, golpe y recibeDanyo cuand esté en contacto con una unidad.
- Asignado tag "Tower" a las torres.
- Añadido case "Tower" a los OnTriggerEnter2D de las unidades para que se detengan y ataquen.
- Modificado bucle Update de las torres, añadidas condiciones de vida <= 0 y recibeDanyo == true para modificar su comportamiento
- Modificados valores de posicion de las unidades para que aparezcan lo suficientemente cerca como para golpear a los enemigos que se encuentren en la torre.
- Añadido Random (float) para generar de vez en cuando un Jinete enemigo
- Añadido el case "Tower" al OnTriggerStay de las unidades, ya que si no al ejecutarse el OnTriggerExit dejan de golpearla.
- Creado script Dinero.
- No encontrada forma de identificar un objeto destruido y añadir dinero al usuario, utilizado variable en el tiempo para sumar dinero.
- Creado un Text en Canvas donde se mosytrará el dinero actual.
- Añadido using UnityEnige.UI al script Dinero para poder identificar el Text Moneda.
- Modificado bucle de Dinero, actualiza el ingreso a tiempo, suma 10 a dinero y cambia el texto del Text cada 2 segundos 
//Moneda.text = dinero.ToString();
- Creado script EnableButton que determinará si un botón es interactuable o no.
- Declaradas variables de tipo GameObject infanteria y caballeria
- Obtenido el valor de interactable de cada boton mediante el metodo GetComponent<Button>().interactable (IsInteractable)
- Obtenido el texto de Moneda y realizado un int.Parse para poder manejar su contenido numéricamente.
- Incluido el código de la clase ClonarObjeto a EnableButton, de esta manera nos ahorramos una clase.
- Impuesta condicion mediante la cual si no disponemos del dinero necesario el boton no será interactuable, en caso de poder interaccionar, se restará el dinero en cuestión.
- Puestos a false las propiedades interactable de los botones en el Start() de EnableButton
- Eliminado script ClonarObjeto
- Añadido control de cuánto dinero hay en el texto antes de sumarlo periódicamente, en la clase Dinero
- Añadidos detalles visuales como una moneda junto al texto del dinero, o un texto indicando el coste de la unidad que genera cada boton
- Añadido Application.LoadlLevel("Juego") en el bucle de las torres cuando su vida llegue a 0, de esta forma reiniciamos el nivel.
- Añadido texto que marcará el número de victorias consecutivas
- 