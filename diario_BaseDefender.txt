
- Descarga de Unity 5.
- Aprendizaje de uso de Unity.
- Tutoriales de internet sobre Unity.
- Descarga de sprites de internet.
- Descarga de las sdk de Android Studio para la exportación del proyecto a Android.
- Configuración del proyecto.
- Pruebas de exportación en C# y JavaScript para Android.
- Creación de escena principal vacía.
- Creación de objeto Jinete de tipo GameObject.
- Asignado sprite a Jinete.
- Creación y asignación de script de movimiento lateral JineteMov.cs para Jinete. Para ello se inicializan variables de tipo float que definirán la velocidad de movimiento del objeto.
//Los objetos de tipo GameObject tienen definidas las variables X e Y que recogen el valor en el eje de las X y de las Y de la pantalla en el lugar en el que se encuentran.
- Creada escena para probar animaciones y terreno.
- Uso de un sprite y un fondo prefabricado de Unity para hacer de fondo del nivel. (Sujeto a cambios)
- Creación de objetos GameObject de torres aliadas y enemigas con un sprite para cada una.
- Asignada propiedad Box Collider 2D para los objetos tipo torre. No asignada la propiedad RigidBody 2D (explicada más adelante).
- Prueba de colisión.
// Las animaciones son clips (.anim)
- Creado modelo animado de Jinete usando la herramienta de animación para sprites de Unity.
- Creación automática de controlador de sprites asignados a cada animación.
- Creada animación para correr y para atacar de Jinete.
- Creado nuevo objeto Jinete y asignada la animación por defecto.
- Creada animación para muerte de las unidades.
- Creada carpeta Prefab en la que se guardan los objetos del juego.
- Guardado Jinete en Prefab.
- Recargado Jinete.
- Asignado cuerpo rígido con propiedades de Unity, RigidBody 2D. 
// Esto controla en el eje de las X y el eje de las Y dónde se encuentra el objeto de tipo GameObject en cada ciclo de juego, además permite activar o desactivar la gravedad, una fuerza de aceleración que ya viene definida en las librerías que importa Unity. Rigidbody 2D es la clase que usa Unity como motor de físicas.
// El Collider establece que el objeto es "sólido" y por tanto el motor de físicas debe detener el GameObject que se encuentre en contacto con este objeto, es decir, cuando su valor X y su valor Y sean el mismo.
// Esto evita que los objetos se atraviesen ya que no pueden ocupar el mismo espacio.
- Añadido Collider a Jinete desde la interfaz de Unity.
- Añadida variable booleana al script de JineteMov.cs para saber si está chocando con algo.
/* En fase de prueba
- Creado nuevo script Movement que será el controlador de cada objeto, en lugar de que cada objeto tenga su propio script de movimiento. 
*/
- Creamos un vector que ponemos a 0 en cada ciclo del juego.
- Creado método colisionEvent, al que le pasamos por parámetro un objeto de tipo Collision2D (en las librerías de Unity viene definido este objeto cuyos valores son los valores de X e Y que ocupa el objeto al que pertenece).
/* En fase de prueba
- Iniciamos una variable de tipo Movement dentro de JineteMov, con la cual controlaremos si debemos mover al Jinete o no.
- Dentro de void Start() (el cual se ejecuta una vez inicializado el objeto) recogemos el valor de la variable de tipo Movement.
*/
- Asignado tag "Enemy" a Jinete.
//Los Colliders tienen definida una variable tag de tipo String por defecto vacía. Puedes escribir desde la interfaz la cadena de caracteres que quieras y mediante una llamada al Collider en otra clase puedes obtener el tag del collider de modo que puedas identificar con qué objeto está entrando en contacto.
- Creado método colision en JineteMov
//Este método busca el nombre del tag del objeto y si coincide ejecuta una accion u otra.
- Creado objeto con animacion Leon, obtenidos sprites de internet.
- Creada animacion de correr para Leon.
- Creada animacion de atacar para Leon.
- Asignada animaciones de leon y animacion de muerte al objeto Leon.
- Asignado tag "Ally" a Leon.
- Modificado script de movimiento de Jinete para reconocer tag de "Ally"
- Asignados los scripts a ambos objetos.
- Ambos objetos se desvían al chocar en lugar de pararse. 
- Establecidas transiciones entre animaciones.
- Creada variable de tipo Animator en el script de movimiento para controlar el estado de la transición de las animaciones según la acción del objeto.
- Establecido ángulo para los objetos mediante la interfaz de Unity, de modo que no roten los objetos al chocar con otros. Mediante esto solucionamos el desvío de los objetos al chocarse.
- Establecido método OnTriggerEnter como sustituto de colision.
- Asignado mediante la interfaz de Unity la variable animator a Jinete.
- Asignado isTrigger mediante la interfaz gráfica de Unity a Jinete y Leon. 
// isTrigger devuelve OnTriggerEnter, OnTriggerExit, OnTriggerStay...
- Sobreescrito método OnTriggerEnter y OnTriggerExit para Jinete.
- Añadido estados para cambiar animacion de Leon
- Pasados componentes "Animator" en forma de variables privadas que son recogidas por getComponent <Animator>
- Añadida funcion de movimiento a Leon y metodos OnTriggerEnter2D y OnTriggerExit2D
- Añadido variables de daño y ataque a Leon y Jinete
- Recogemos el objeto JineteMov desde Leon con GetComponent<JineteMov>
- Obtenemos el daño de la unidad en cuestión.
// En C# importas namespaces, no como en Java que importas types directamente.
-  Cambiado métodos, eliminado GetComponent por problemas técnicos, asignado un switch en el que buscamos el tag y según su resultado modificamos la variable daño, aplicamos un estado de animacion y avanzamos a detenemos el objeto.
- Creados metodos detenerVelocidad() que establece this.X a 0 y resetVelocidad para devolver this.X a su valor original.
- Asignados los tag de forma manual mediante gameObject.tag
- En el Update restamos a vida el valor de daño.
- Fallo en el bucle, se ha de controlar el tiempo de la aplicación para disminuir la vida de forma no instantánea o infinita.
- Añadida variable recibeDanyo de tipo bool
- Añadida condicion a bucle Update, si recibeDanyo es true, le restamos a vida danyo
- Añadido if a bucle Update, si vida <= 0, pasamos AnimState a 2 para activar la animacion de muerte
- Creado método destruirObjeto, dentro usamos Destroy (this.gameObject)
- Creado variable choque y tiempo que guardan el tiempo (Time.time) en el que se encuentra la aplicación. 
- Inicializado choque en OnTriggerEnter2D, de modo que es el tiempo en el que chocan los objetos.
- La variable tiempo la guardamos en el Update, de modo que está continuamente guardando el tiempo en el que se encuentra la aplicación desde que se inició.
- Mediante un if comparamos si la diferencia entre tiempo y choque es de 1 segundo, si es el caso, esto restará danyo a la vida del objeto.
- Renombrado choque a golpe.
- Redefinido golpe por cada vez que disminuimos la vida, lo igualamos a tiempo, de modo que tenga que volver a haber una diferencia de un segundo para disminuir vida.
- Añadida condición del mismo modo que antes, que la resta de tiempo-golpe sea >= 1, esta vez en el if en el que entra cuando vida llega a 0, para dar un segundo a la animación de muerte antes de destruir el objeto.
- Añadido a la condicion que recibeDanyo sea false, lo cual ocurrirá cuando vida llegue a 0 o menos. Esto es porque de lo contrario, seguimos entrando en el bucle que modifica golpe a tiempo y nunca entramos en la condicion que destruye el objeto. De esta forma dejamos de actualizar golpe a tiempo y cuando tiempo-golpe >= 1, el objeto se destruirá mediante el método destruirObjeto() creado anteriormente.
- Añadido recibeDanyo = false a OnTriggerExit2D
- Creado objeto Soldado, animado con animaciones de movimiento, ataque y muerte usando el animador de Unity
- Creado el script SoldadoMov.cs
- Añadido transform.localScale para Soldado porque el sprite miraba en la otra dirección.
- Añadido tag "SoldadoAlly"
- Quitada gravedad y fijado el ángulo mediante la interfaz de Unity.
- Creado SoldadoEnemy, animaciones de correr atacar y morir
- Creado script SoldadoEnemyMov.cs para SoldadoEnemy
- Añadido componentes RigidBody 2D, Box Collider 2D para los nuevos soldados
- Hechos IsTrigger, angulo fijado y gravedad 0 mediante la interfaz.
- Eliminado el script Movement.
- Descubierto errata, cuando objetos aliados chocan, no se superponen si no que se bloquean entre ellos.
- Eliminado componente RigidBody 2D de los objetos.
- Cambiado OnTriggerEnter2D (Collider2D target) y demás eventos por OnCollisionEnter2D (Collision2D target)
- Añadido OnCollisionStay2D para el comportamiento mientras permanecen chocando.
- Guardados todos los gameObject en la carpeta Prefabs
- Iniciada escena Menu
- Importados sprites de edificios, terreno y skybox
- Leer y aprender cómo usar el Canvas de Unity
